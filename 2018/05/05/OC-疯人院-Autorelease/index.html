<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC 疯人院 - Autorelease · 红纸</title><meta name="description" content="OC 疯人院 - Autorelease - HongZhi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.zhz.io/atom.xml" title="红纸"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nianran" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC 疯人院 - Autorelease</h1><div class="post-info">May 5, 2018</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Autorelease-&gt;苹果在内存管理方面的优化策略，旨在方便开发者更加良好的管理对象的内存空间，做到OC对象无需开发者手动进行释放操作。<br>其是在OC从MRC转变为ARC中间形成的产物。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文的所有内容均已下述标准下进行的实验</p>
<ul>
<li><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc源码（可编译版本）,tag号为723版本</a></li>
<li><a href="https://github.com/nianran/objc-runtime/tree/Feature/translation" target="_blank" rel="noopener">个人实验的路径,包含部分Demo，以及源码注解，欢迎指教</a></li>
<li>Xcode Version 9.3 (9E145)</li>
<li>Hopper Disassembler v4</li>
</ul>
<h2 id="从最熟悉的地方开始"><a href="#从最熟悉的地方开始" class="headerlink" title="从最熟悉的地方开始"></a>从最熟悉的地方开始</h2><p>main函数，敲过代码的都知道，很多语言都是从main函数开始的（写个Hello,world!,哈哈哈）<br>OK，那么我们从main函数开始，下面贴的就是main函数在编译前和编译后（反编译出来）的对比<br><a id="more"></a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原代码</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        testRetainCount();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Hopper 反编译后的代码</span></div><div class="line"><span class="keyword">int</span> _main(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1) &#123;</div><div class="line">    <span class="keyword">void</span> *context = objc_autoreleasePoolPush();</div><div class="line">    _testRetainCount();</div><div class="line">    objc_autoreleasePoolPop(context);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从中，我们可以看到@autoreleasepool{}这个东西实质上是被替换成了以前以后的两个函数</p>
<ul>
<li>objc_autoreleasePoolPush()</li>
<li>objc_autoreleasePoolPop(void *)<br>OK，在讲这两个函数之前，我们有必要先了解一下这么一个类AutoreleasePoolPage</li>
</ul>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><h3 id="AutoreleasePoolPage类的简介"><a href="#AutoreleasePoolPage类的简介" class="headerlink" title="AutoreleasePoolPage类的简介"></a>AutoreleasePoolPage类的简介</h3><p>AutoreleasePoolPage(自动释放池页？这个翻译好奇怪，我们这边就约定为释放页/page吧)。<br>那么这个东西是什么呢，它其实是用来管理需要自动释放对象的一个<a href="https://zh.wikipedia.org/zh-hans/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">双向链表</a><br>OK,我们盗个图，嘻嘻<a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">来源</a><br><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg" alt="AutoreleasePoolPage类"><br>简单介绍一下元素</p>
<ul>
<li>next:作为一个游标，用来指定下一个会被添加进来的对象的起始地址</li>
<li>thread:当前page所在的线程（page和线程是一一对应的关系）</li>
<li>child/parent:双向链表的福字节点，没什么好说明的。</li>
<li>Size:一个page被宏定义的SIZE限制在了4096字节，所以超过4K的话，就会创建新的childpage来存储</li>
<li>depth:链表深度，根链表为0，后续持续+1</li>
</ul>
<p>OK，看完了图，我们来看下AutoreleasePoolPage的构造函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数</span></div><div class="line">AutoreleasePoolPage(AutoreleasePoolPage *newParent) </div><div class="line">    : magic(), next(begin()), thread(pthread_self()),</div><div class="line">      parent(newParent), child(<span class="literal">nil</span>), </div><div class="line">      depth(parent ? <span class="number">1</span>+parent-&gt;depth : <span class="number">0</span>), </div><div class="line">      hiwat(parent ? parent-&gt;hiwat : <span class="number">0</span>)</div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> (parent) &#123;</div><div class="line">        parent-&gt;check();</div><div class="line">        assert(!parent-&gt;child);</div><div class="line">        parent-&gt;unprotect();</div><div class="line">        parent-&gt;child = <span class="keyword">this</span>;</div><div class="line">        parent-&gt;protect();</div><div class="line">    &#125;</div><div class="line">    protect();</div><div class="line">&#125;</div><div class="line"><span class="comment">// begin函数</span></div><div class="line"><span class="keyword">id</span> * begin() &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span> *) ((uint8_t *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: 在C++中，冒号后面是赋值，next(begin())就是next=begin()</p>
</blockquote>
<p> 最后，在内存中的表现就会如下图所示,<a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">来源</a><br><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg" alt="AutoreleasePoolPage内存中的表现形式"><br>结合代码和上图，我们可以知道，新的page的next指针被指向begin的位置（实例内存之后）</p>
<h3 id="hotPage"><a href="#hotPage" class="headerlink" title="hotPage()"></a>hotPage()</h3><p>什么是hotPage呢？<br>hotPage就是当前内存中最活跃的那一页,被用来存储当前线程快速存储的对象的时候使用的。<br>获取的方式TLS（Thread Local Storage），这块并不懂，也不想深究，简单明了的理解就是一个全局表，用key来换取value，value就是当前的活跃页。<br>如有兴趣了解TLS参考<a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">大神博客</a></p>
<h2 id="对象是何时被加入到page中的呢？"><a href="#对象是何时被加入到page中的呢？" class="headerlink" title="对象是何时被加入到page中的呢？"></a>对象是何时被加入到page中的呢？</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>在开始讲对象是怎么被加入页中，我们从一个实验中来看<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">void</span> * -[Person person](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</div><div class="line">    var_18 = [[Person alloc] init];</div><div class="line">    var_28 = [var_18 <span class="keyword">retain</span>];</div><div class="line">    objc_storeStrong(var_18, <span class="number">0x0</span>);</div><div class="line">    rax = [var_28 autorelease];</div><div class="line">    <span class="keyword">return</span> rax;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Person *)person &#123;</div><div class="line">    Person *person = [[Person alloc] init];</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> -[Person person1](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</div><div class="line">    rdi = var_18;</div><div class="line">    [[Person alloc] init];</div><div class="line">    objc_storeStrong(rdi, <span class="number">0x0</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)person1 &#123;</div><div class="line">    Person *person = [[Person alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>对比两个函数person和person1函数，从反编译器的代码中我们可以看出来，对于超出作用于范围函数的对象，是不会被加入到autoReleasePool中的，但是如果会超出了函数作用于范围的值，那么编译器会帮助你主动加上autoRelease这个函数的。<br>那么我们来看一下autoRelease的函数调用关系</p>
<ul>
<li>[self autorelease]<ul>
<li>((id)self)-&gt;rootAutorelease();<ul>
<li>rootAutorelease2();<ul>
<li>AutoreleasePoolPage::autorelease((id)this); // this就是oc中的self<ul>
<li>autoreleaseFast(obj) // obj就是传入的self<ul>
<li>page-&gt;add(obj)<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 线程安全的，找到当前页</span></div><div class="line">    <span class="comment">// hotPage:以全局的key(static pthread_key_t const key = AUTORELEASE_POOL_KEY;)存储的一份实例，动态更新双向页链表中最后一个节点</span></div><div class="line">    <span class="comment">// 都是同一个套路</span></div><div class="line">    <span class="comment">//  1. 存在页 跳转3</span></div><div class="line">    <span class="comment">//  2. 不存在页 创建页 跳转5</span></div><div class="line">    <span class="comment">//  3. 页是否满了 跳转5</span></div><div class="line">    <span class="comment">//  4. 添加obj 跳转6</span></div><div class="line">    <span class="comment">//  5. 设置hotPage 跳转4</span></div><div class="line">    <span class="comment">//  6. 结束</span></div><div class="line">    AutoreleasePoolPage *page = hotPage(); <span class="comment">// 找到当前活跃的PoolPage</span></div><div class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        <span class="comment">// 存在页, 未满 -&gt; 添加</span></div><div class="line">        <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</div><div class="line">        <span class="comment">// 存在页, 已满 -&gt; 新建后添加</span></div><div class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不存在页 -&gt; 新建页后添加</span></div><div class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其实add操作就是将obj的指针加入page的next的位置，然后next位置上移<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    assert(!full());</div><div class="line">    unprotect();</div><div class="line">    <span class="keyword">id</span> *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></div><div class="line">    *next++ = obj;</div><div class="line">    protect();</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>objc_storeStrong增加引用计数的时候使用，但是这边是成员变量，并不会引起引用计数的增加</p>
</blockquote>
<h2 id="对象又是什么时候被释放的呢？"><a href="#对象又是什么时候被释放的呢？" class="headerlink" title="对象又是什么时候被释放的呢？"></a>对象又是什么时候被释放的呢？</h2><p>至此，我们已经了解到了，对象是如何被加入到page中的，接下来，我们要了解，对象的释放时机</p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>OK，那么我们回到文中最开始的那两个函数<br>objc_autoreleasePoolPush()<br>objc_autoreleasePoolPop(content)<br>每次调用objc_autoreleasePoolPush其实都是在给hotPage的栈顶添加一个哨兵对象，值为0，那么就会变成这个样子<br>（继续盗图<a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">来源</a>）<br><img src="http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg" alt="哨兵对象"><br>那么<em>objc_autoreleasePoolPush()</em>的返回值就是这个哨兵对象的地址，后续可以成为<em>objc_autoreleasePoolPop</em>的入参进行使用,于是乎就有如下结论</p>
<ul>
<li>根据传入的哨兵对象地址，找到对应的page页</li>
<li>根据page页和哨兵地址，将在哨兵对象添加时间后的对象全部调用release函数，并重置next指针<blockquote>
<p>如果最开始的page是没有哨兵的怎么办？因为page的初始化有唯一值来控制，是个static类型，如果相同，那么直接会对对象全部发送release操作，并且page清空</p>
</blockquote>
</li>
</ul>
<h3 id="autoRelease和runloop的关系"><a href="#autoRelease和runloop的关系" class="headerlink" title="autoRelease和runloop的关系"></a>autoRelease和runloop的关系</h3><p>这块儿没有仔细的研究，抄一抄别人写的描述,<a href="https://blog.csdn.net/u011619283/article/details/53783650" target="_blank" rel="noopener">来源</a><br>我们总是看到有文章说程序启动后，苹果在主线程 RunLoop 里注册了两个 Observer：<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入睡眠) 和 Exit(即将退出Loop)，<br>BeforeWaiting(准备进入睡眠)时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；<br>Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>打印出MainRunLoop，可以看到MainRunLoop的 Common mode Items 中就有这两个观察者<br><img src="/resources/D35DF794164F53C79121DA4C53C3CA27.jpg" alt="IMAGE"></p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>保证线程访问安全？<br><a href="https://blog.csdn.net/roland_sun/article/details/33728955" target="_blank" rel="noopener">Linux中mprotect()函数的用法</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protect();</div><div class="line">unprotect();</div></pre></td></tr></table></figure></p>
<p>objc_storeStrong的研究<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> objc_storeStrong(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> prev = *location;</div><div class="line">    <span class="keyword">if</span> (obj == prev) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    objc_retain(obj);</div><div class="line">    *location = obj;</div><div class="line">    objc_release(prev);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 真正的set方法，是不会直接return掉的</span></div><div class="line">objc_storeStrong(<span class="number">0x0</span>, rax);</div><div class="line"></div><div class="line"><span class="comment">// 临时变量，会直接在内部return掉</span></div><div class="line">objc_storeStrong(var_8, <span class="number">0x0</span>);</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></li>
<li><a href="https://blog.csdn.net/u011619283/article/details/53783650" target="_blank" rel="noopener">RunLoop总结：RunLoop 与GCD 、Autorelease Pool之间的关系</a></li>
</ol>
<!--定义-->
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/05/OC-疯人院-引用计数/" class="prev">上一篇</a><a href="/2018/05/05/OC-疯人院-ISA/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zhz';
var disqus_identifier = '2018/05/05/OC-疯人院-Autorelease/';
var disqus_title = 'OC 疯人院 - Autorelease';
var disqus_url = 'http://www.zhz.io/2018/05/05/OC-疯人院-Autorelease/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zhz.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2018 <a href="http://www.zhz.io">HongZhi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-82278125-1",'auto');ga('send','pageview');</script></body></html>