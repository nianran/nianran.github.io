<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 红纸</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.zhz.io/atom.xml" title="红纸"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nianran" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/06/2017傻瓜式总结/" class="post-title-link">2017傻瓜式总结</a></h2><div class="post-info">Jan 6, 2018</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OK~工作一年了哈，博客一直没有管，组内事情太多（借口，太懒），虽然写了一堆的文章，但是基本上都是在组内发布了。对外么，部分受限于公司协议之类的，部分是暂时觉得水平有限（反正也没什么人看么）。</p>
<h2 id="回顾2016年立的Flag-amp-Bad"><a href="#回顾2016年立的Flag-amp-Bad" class="headerlink" title="回顾2016年立的Flag &amp; Bad"></a>回顾2016年立的Flag &amp; Bad</h2><ul>
<li>明确自己的人生目标<br>在这一点上，应该考虑了很久才对，但是一直没有给自己一个明确的答案。<br>但是应该有了一系列的目标。<ol>
<li>财务自由？不不不，精神自由。在40岁以后能够达到精神自由，不再受限于生活中的种种因素的干扰。毕竟精神自由取决于个人，我觉得我是一个比较感性的人，钱虽然是越多越好，但是钱么，我觉得够用就好。过上舒舒服服的小日子。但是在此之前就必须要好好努力才可以</li>
<li>在技术上有所突破，为后来人留下一些真正有用的东西，再者是提高一些知名度。2018，一个月至少一篇以上有含量的技术分享，为之努力吧，也只能这么说一说了。</li>
</ol>
</li>
<li>去一次日本<br>没去，其他地方倒是去了好几个，对我个人来说也是很棒的体验。</li>
<li>能够从容的应对各种事情<br>在这个方面，我觉得个人做的还可以，练就了’Pocker Face’，只不过还有待加强心理承受能力吧，主要还是靠这个，心理承受能力好了才行。不然应对一些事情的时候，会不知所措。</li>
</ul></div><a href="/2018/01/06/2017傻瓜式总结/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/10/11/晴明视频学习笔记-第四章/" class="post-title-link">RN晴明视频学习笔记 - 第四章</a></h2><div class="post-info">Oct 11, 2017</div><div class="post-content"><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><h3 id="详细的生命周期文档"><a href="#详细的生命周期文档" class="headerlink" title="详细的生命周期文档"></a>详细的生命周期文档</h3><p><a href="https://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="noopener">博客</a></p>
<h3 id="其他Tips"><a href="#其他Tips" class="headerlink" title="其他Tips"></a>其他Tips</h3><ul>
<li>render中只做与渲染有关的操作，只读取、不修改任何数据（临时变量除外）<ul>
<li>因为界面的更改是经常的，所以render是经常触发的</li>
<li>所以如果你有修改数据等操作，就会多次触发，使结果难以预料</li>
<li>比如你执行setState，那么setState又触发render，就会导致死循环</li>
</ul>
</li>
<li>随组件加载只执行一次的操作，放在WillMount或者DidMount中<ul>
<li>比如远程取首页数据（fetch），比如弹出提示框</li>
</ul>
</li>
<li>记得在WillUnmount中销毁定时器和一些订阅事件</li>
<li>props发生变化，使用WillReceiveProps来处理（比如将变动同步给state）</li>
</ul></div><a href="/2017/10/11/晴明视频学习笔记-第四章/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/09/12/RN晴明视频学习笔记-第三章/" class="post-title-link">RN晴明视频学习笔记 - 第三章</a></h2><div class="post-info">Sep 12, 2017</div><div class="post-content"><h2 id="ReactJS和ReactNative"><a href="#ReactJS和ReactNative" class="headerlink" title="ReactJS和ReactNative"></a>ReactJS和ReactNative</h2><h3 id="两者区别比较"><a href="#两者区别比较" class="headerlink" title="两者区别比较"></a>两者区别比较</h3><p><img src="/resources/44D051F354FFBF35A300E1F8C731FD9B.jpg" alt="IMAGE"></p>
<ul>
<li>最重要的区别莫过于是控件方面的区别，对应的分别是对应平台的组件</div><a href="/2017/09/12/RN晴明视频学习笔记-第三章/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/09/10/晴明视频学习笔记-第二章/" class="post-title-link">RN晴明视频学习笔记 - 第二章</a></h2><div class="post-info">Sep 10, 2017</div><div class="post-content"><h2 id="原生-Hybird-RN"><a href="#原生-Hybird-RN" class="headerlink" title="原生/Hybird/RN"></a>原生/Hybird/RN</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>形式</th>
<th>介绍</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>原生</td>
<td>使用原生语言进行编写开发</td>
<td>性能好/有生态圈的优势点</td>
<td>各个平台有各自的语言，学习成本大，不兼容</td>
</tr>
<tr>
<td>Hybrid App混合开发</td>
<td>使用前段代码，在各个平台上有他的容器WebView，利用他进行渲染</td>
<td>跨平台，适合简单应用</td>
<td>性能不是很好 </td>
</tr>
<tr>
<td>RN</td>
<td>较于前面两者之间，使用JS开发，翻译成原生组件进行展示</td>
<td>学习成本低，天然跨平台，无审核热更新，具有优秀的社区能力（开源库）</td>
<td>性能</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>名词解释：ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<p>简单的说：ECMAScript是一种标准文本语法，JS是根据其进行设计的</p></div><a href="/2017/09/10/晴明视频学习笔记-第二章/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/17/ReactiveCocoa-双向绑定，不完全解析/" class="post-title-link">ReactiveCocoa - 双向绑定，不完全解析</a></h2><div class="post-info">Aug 17, 2017</div><div class="post-content"><h3 id="RACChannelTerminal"><a href="#RACChannelTerminal" class="headerlink" title="RACChannelTerminal"></a>RACChannelTerminal</h3><p>我们先来看看双向绑定这件事情。<br><img src="resources/41863AF8A61873D1D38D72BF3C38FC69.jpg" alt="IMAGE"><br>我们如何实现信号从A传到B，又可以从B传到A呢。利用信号的双向传递的话，我们可以用RACSubject，这样A发的信号B就能接到，而且B发的信号A也能够接收到。<br><img src="resources/3333985DB5A5A590D5966CFDDFDC34A6.jpg" alt="IMAGE"><br></div><a href="/2017/08/17/ReactiveCocoa-双向绑定，不完全解析/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/05/Advanced-Apple-Debugging阅读笔记Part1/" class="post-title-link">Advanced_Apple_Debugging阅读笔记Part1</a></h2><div class="post-info">Jun 5, 2017</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为<a href="https://store.raywenderlich.com/products/advanced-apple-debugging-and-reverse-engineering" target="_blank" rel="noopener">Advanced Apple Debugging &amp; Reverse Engineering</a>的第一章阅读笔记，<br>有不正之处望指正</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>关闭Rootless模式</p>
<ul>
<li>重启电脑，启动后长按Commond+R</li>
<li>进入控制台</li>
<li>输入 csrutil disable; reboot</li>
<li>不久后就会重启电脑</li>
</ul>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ lldb /Projects/Sketch/build/Debug/Sketch.app </div><div class="line">&gt;&gt; Current executable set to &apos;/Projects/Sketch/build/Debug/Sketch.app&apos; (x86_64)</div></pre></td></tr></table></figure>
<p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ lldb </div><div class="line">(lldb) file /Projects/Sketch/build/Debug/Sketch.app </div><div class="line">&gt;&gt; Current executable set to &apos;/Projects/Sketch/build/Debug/Sketch.app&apos; (x86_64).</div></pre></td></tr></table></figure></p></div><a href="/2017/06/05/Advanced-Apple-Debugging阅读笔记Part1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/15/Block-的为什么会有循环引用/" class="post-title-link">Block 的为什么会有循环引用</a></h2><div class="post-info">Mar 15, 2017</div><div class="post-content"><h2 id="这次分享要解决的问题"><a href="#这次分享要解决的问题" class="headerlink" title="这次分享要解决的问题"></a>这次分享要解决的问题</h2><p>Block 为什么会引起循环引用</p>
<h2 id="本次实验"><a href="#本次实验" class="headerlink" title="本次实验"></a>本次实验</h2><ul>
<li>平台信息</li>
<li>Apple LLVM version 8.0.0 (clang-800.0.42.1)</li>
<li>Target: x86_64-apple-darwin16.4.0</li>
<li>Thread model: posix</li>
<li>InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</li>
<li>MRC</li>
</ul></div><a href="/2017/03/15/Block-的为什么会有循环引用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/31/我的2016年总结/" class="post-title-link">我的2016年总结</a></h2><div class="post-info">Dec 31, 2016</div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>呵呵哒，这好像是我第一次写这种总结（非逼迫性），来记录一下今年我都干了写啥蠢事。<br>OK~2016年，就这样过去了，这几天看了几个小伙伴和一些人的博客，套用下模板吧。The Good The Bad</p>
<h2 id="0x01-The-Good"><a href="#0x01-The-Good" class="headerlink" title="0x01 The Good"></a>0x01 The Good</h2><p>今年顺利毕业了，算是度过了人生中最后一段学校的时光。<br>今年的变化还是挺多的吧，单从职业上来说，从学生变成了从业者。从生活上来说，从一个满受父母关怀的孩子变成了一个独立者。</p>
<h2 id="看了挺多的书"><a href="#看了挺多的书" class="headerlink" title="看了挺多的书"></a>看了挺多的书</h2><p>今年看了挺多的书吧，比如说CA、OC编程之道、Effective Objective-C、代码之外的生存指南等等。收益良多，了解了更多iOS底层的东西，对于后续帮助的确挺大的。<br></div><a href="/2016/12/31/我的2016年总结/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/15/Cocoapods常用命令/" class="post-title-link">Cocoapods常用命令</a></h2><div class="post-info">Dec 15, 2016</div><div class="post-content"><h1 id="0x00-Pod基础"><a href="#0x00-Pod基础" class="headerlink" title="0x00 Pod基础"></a>0x00 Pod基础</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod --help 这个可以用来所有的命令</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pod [Commond] [Options]</div><div class="line">$ pod install --verbose --no-repo-update</div></pre></td></tr></table></figure></div><a href="/2016/12/15/Cocoapods常用命令/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/08/25/Shared Keychain Access/" class="post-title-link">Share Keychain Access</a></h2><div class="post-info">Aug 25, 2016</div><div class="post-content"><h2 id="0x00-什么是Keychain"><a href="#0x00-什么是Keychain" class="headerlink" title="0x00 什么是Keychain"></a>0x00 什么是Keychain</h2><p>据介绍，Keychain是iOS系统官方提供的安全存储容器，我们可以用它来存一些敏感信息，EG:密码，用户名，证书等等。<br>Mac电脑上自带的Keychain Access.app就是苹果自己的Keychain读取软件。<br>Keychain是保存在沙盒之外的数据库的，所以在删除App后，在重新下载App后，这些信息依旧存在，并且你可以通过设置一些属性，让你的数据保#####存到iCloud中，达到跨设备存储。</p>
<h2 id="0x01-Keychain本质是什么"><a href="#0x01-Keychain本质是什么" class="headerlink" title="0x01 Keychain本质是什么"></a>0x01 Keychain本质是什么</h2><p>Keychain存储本质是Sqlite。真机地址：/private/var/Keychains/keychain-2.db<br>既然是Sqlite，那么Keychain存储的对象（后面统称为Item），即对应Sqlite上的一条记录而已。</p></div><a href="/2016/08/25/Shared Keychain Access/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"></div><div class="copyright"><p>© 2016 - 2018 <a href="http://www.zhz.io">HongZhi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-82278125-1",'auto');ga('send','pageview');</script></body></html>