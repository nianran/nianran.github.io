<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 红纸</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.zhz.io/atom.xml" title="红纸"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/nianran" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/06/10/WWDC-2018-412-Advanced-Debugging-With-Xcode-and-LLDB/" class="post-title-link">WWDC 2018 - 412 Advanced Debugging With Xcode and LLDB</a></h2><div class="post-info">Jun 10, 2018</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚做完了这个<a href="https://developer.apple.com/videos/play/wwdc2018/412/" target="_blank" rel="noopener">Advanced Debugging with Xcode and LLDB Session 412</a>的听力练习，来写个小总结(嗯，又可以愉快的开始装逼了)。<br>由于Swift写的不多，可能有几个小部分了解的并不是很全面</p>
<h2 id="增加了Swift-Debug的可靠性"><a href="#增加了Swift-Debug的可靠性" class="headerlink" title="增加了Swift Debug的可靠性"></a>增加了Swift Debug的可靠性</h2><h3 id="Swift第三方库导入方式不正确，导致的属性无法打印问题修正"><a href="#Swift第三方库导入方式不正确，导致的属性无法打印问题修正" class="headerlink" title="Swift第三方库导入方式不正确，导致的属性无法打印问题修正"></a>Swift第三方库导入方式不正确，导致的属性无法打印问题修正</h3><p>产生原因可以直接看这个<a href="https://juejin.im/post/5a52d7cdf265da3e4c07a004" target="_blank" rel="noopener">链接</a><br>实际产生的效果<br><img src="/resources/C377778880889F7F0B8897607C911E7A.jpg" alt="IMAGE"></p>
<h3 id="控制台Swift类型修正"><a href="#控制台Swift类型修正" class="headerlink" title="控制台Swift类型修正"></a>控制台Swift类型修正</h3><p><img src="/resources/CDA3BBFB82087B559010B162AAF25A8F.jpg" alt="IMAGE"><br></div><a href="/2018/06/10/WWDC-2018-412-Advanced-Debugging-With-Xcode-and-LLDB/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/18/记一次-Alfred-Workflow中Confluence改造/" class="post-title-link">记一次 Alfred Workflow中Confluence改造</a></h2><div class="post-info">May 18, 2018</div><div class="post-content"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>Confluence对于企业来说是一个非常有用的文档管理工具，但是每次我在使用的时候，我都要去进行一遍文档空间的目录查找。<br>虽然提供了搜索功能，但是搜索的延时，使用便捷度，都存在一定的问题。（哦，对了我们的Confluence是比较低版本的，太老了，一次搜索50条）<br>那么，想了一下如何去解决这个问题呢，Mac中万能的Alfred Workflow就是用来解决一系列的工作效率的问题的。<br>所以我在尝试能不能用Alfred Workflow来进行文档标题的搜索。<br>OK做这个事情之前，先找下目前有没有已经存在的包拿来直接使用。<br>找到了这个<a href="https://github.com/skleinei/alfred-confluence" target="_blank" rel="noopener">Alfred Workflow</a>，但是按照他的设置却发现搜索不了结果。<br></div><a href="/2018/05/18/记一次-Alfred-Workflow中Confluence改造/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/05/OC-疯人院-引用计数/" class="post-title-link">OC 疯人院 - 引用计数</a></h2><div class="post-info">May 5, 2018</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在MRC时代，引用计数是由我们开发者自己控制的，但是到了ARC时代，编译器帮我们做了引用计数管理这一步。这边的描述，就是为了解密，引用计数是如何实现的。如果不知道什么是引用计数，请参考其他人的文章~</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文的所有内容均已下述标准下进行的实验</p>
<ul>
<li><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc源码（可编译版本）,tag号为723版本</a></li>
<li><a href="https://github.com/nianran/objc-runtime/tree/Feature/translation" target="_blank" rel="noopener">个人实验的路径,包含部分Demo，以及源码注解，欢迎指教</a></li>
<li>Xcode Version 9.3 (9E145)</li>
<li>Hopper Disassembler v4</li>
<li>以模拟器为准的话是x86_64，不同架构会有区别</li>
<li>本次实验内容，不涉及指针优化（TaggedPointer）</div><a href="/2018/05/05/OC-疯人院-引用计数/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/05/OC-疯人院-Autorelease/" class="post-title-link">OC 疯人院 - Autorelease</a></h2><div class="post-info">May 5, 2018</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Autorelease-&gt;苹果在内存管理方面的优化策略，旨在方便开发者更加良好的管理对象的内存空间，做到OC对象无需开发者手动进行释放操作。<br>其是在OC从MRC转变为ARC中间形成的产物。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文的所有内容均已下述标准下进行的实验</p>
<ul>
<li><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc源码（可编译版本）,tag号为723版本</a></li>
<li><a href="https://github.com/nianran/objc-runtime/tree/Feature/translation" target="_blank" rel="noopener">个人实验的路径,包含部分Demo，以及源码注解，欢迎指教</a></li>
<li>Xcode Version 9.3 (9E145)</li>
<li>Hopper Disassembler v4</li>
</ul>
<h2 id="从最熟悉的地方开始"><a href="#从最熟悉的地方开始" class="headerlink" title="从最熟悉的地方开始"></a>从最熟悉的地方开始</h2><p>main函数，敲过代码的都知道，很多语言都是从main函数开始的（写个Hello,world!,哈哈哈）<br>OK，那么我们从main函数开始，下面贴的就是main函数在编译前和编译后（反编译出来）的对比<br></div><a href="/2018/05/05/OC-疯人院-Autorelease/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/05/OC-疯人院-ISA/" class="post-title-link">OC 疯人院 - ISA</a></h2><div class="post-info">May 5, 2018</div><div class="post-content"><h2 id="介绍ISA"><a href="#介绍ISA" class="headerlink" title="介绍ISA"></a>介绍ISA</h2><p>Emmm,这个写到吐了，都不知道看第几遍Or写第几遍了，以前公司分享的，不能搬出来。<br>大家直接看大神的博客就可以了，后面的一些，我慢慢写，哈哈哈。<br><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md" target="_blank" rel="noopener">链接</a><br></div><a href="/2018/05/05/OC-疯人院-ISA/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/06/2017傻瓜式总结/" class="post-title-link">2017傻瓜式总结</a></h2><div class="post-info">Jan 6, 2018</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OK~工作一年了哈，博客一直没有管，组内事情太多（借口，太懒），虽然写了一堆的文章，但是基本上都是在组内发布了。对外么，部分受限于公司协议之类的，部分是暂时觉得水平有限（反正也没什么人看么）。</p>
<h2 id="回顾2016年立的Flag-amp-Bad"><a href="#回顾2016年立的Flag-amp-Bad" class="headerlink" title="回顾2016年立的Flag &amp; Bad"></a>回顾2016年立的Flag &amp; Bad</h2><ul>
<li>明确自己的人生目标<br>在这一点上，应该考虑了很久才对，但是一直没有给自己一个明确的答案。<br>但是应该有了一系列的目标。<ol>
<li>财务自由？不不不，精神自由。在40岁以后能够达到精神自由，不再受限于生活中的种种因素的干扰。毕竟精神自由取决于个人，我觉得我是一个比较感性的人，钱虽然是越多越好，但是钱么，我觉得够用就好。过上舒舒服服的小日子。但是在此之前就必须要好好努力才可以</li>
<li>在技术上有所突破，为后来人留下一些真正有用的东西，再者是提高一些知名度。2018，一个月至少一篇以上有含量的技术分享，为之努力吧，也只能这么说一说了。</li>
</ol>
</li>
<li>去一次日本<br>没去，其他地方倒是去了好几个，对我个人来说也是很棒的体验。</li>
<li>能够从容的应对各种事情<br>在这个方面，我觉得个人做的还可以，练就了’Pocker Face’，只不过还有待加强心理承受能力吧，主要还是靠这个，心理承受能力好了才行。不然应对一些事情的时候，会不知所措。</li>
</ul></div><a href="/2018/01/06/2017傻瓜式总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/10/11/晴明视频学习笔记-第四章/" class="post-title-link">RN晴明视频学习笔记 - 第四章</a></h2><div class="post-info">Oct 11, 2017</div><div class="post-content"><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><h3 id="详细的生命周期文档"><a href="#详细的生命周期文档" class="headerlink" title="详细的生命周期文档"></a>详细的生命周期文档</h3><p><a href="https://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="noopener">博客</a></p>
<h3 id="其他Tips"><a href="#其他Tips" class="headerlink" title="其他Tips"></a>其他Tips</h3><ul>
<li>render中只做与渲染有关的操作，只读取、不修改任何数据（临时变量除外）<ul>
<li>因为界面的更改是经常的，所以render是经常触发的</li>
<li>所以如果你有修改数据等操作，就会多次触发，使结果难以预料</li>
<li>比如你执行setState，那么setState又触发render，就会导致死循环</li>
</ul>
</li>
<li>随组件加载只执行一次的操作，放在WillMount或者DidMount中<ul>
<li>比如远程取首页数据（fetch），比如弹出提示框</li>
</ul>
</li>
<li>记得在WillUnmount中销毁定时器和一些订阅事件</li>
<li>props发生变化，使用WillReceiveProps来处理（比如将变动同步给state）</li>
</ul></div><a href="/2017/10/11/晴明视频学习笔记-第四章/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/09/12/RN晴明视频学习笔记-第三章/" class="post-title-link">RN晴明视频学习笔记 - 第三章</a></h2><div class="post-info">Sep 12, 2017</div><div class="post-content"><h2 id="ReactJS和ReactNative"><a href="#ReactJS和ReactNative" class="headerlink" title="ReactJS和ReactNative"></a>ReactJS和ReactNative</h2><h3 id="两者区别比较"><a href="#两者区别比较" class="headerlink" title="两者区别比较"></a>两者区别比较</h3><p><img src="/resources/44D051F354FFBF35A300E1F8C731FD9B.jpg" alt="IMAGE"></p>
<ul>
<li>最重要的区别莫过于是控件方面的区别，对应的分别是对应平台的组件</div><a href="/2017/09/12/RN晴明视频学习笔记-第三章/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/09/10/晴明视频学习笔记-第二章/" class="post-title-link">RN晴明视频学习笔记 - 第二章</a></h2><div class="post-info">Sep 10, 2017</div><div class="post-content"><h2 id="原生-Hybird-RN"><a href="#原生-Hybird-RN" class="headerlink" title="原生/Hybird/RN"></a>原生/Hybird/RN</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>形式</th>
<th>介绍</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>原生</td>
<td>使用原生语言进行编写开发</td>
<td>性能好/有生态圈的优势点</td>
<td>各个平台有各自的语言，学习成本大，不兼容</td>
</tr>
<tr>
<td>Hybrid App混合开发</td>
<td>使用前段代码，在各个平台上有他的容器WebView，利用他进行渲染</td>
<td>跨平台，适合简单应用</td>
<td>性能不是很好 </td>
</tr>
<tr>
<td>RN</td>
<td>较于前面两者之间，使用JS开发，翻译成原生组件进行展示</td>
<td>学习成本低，天然跨平台，无审核热更新，具有优秀的社区能力（开源库）</td>
<td>性能</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>名词解释：ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<p>简单的说：ECMAScript是一种标准文本语法，JS是根据其进行设计的</p></div><a href="/2017/09/10/晴明视频学习笔记-第二章/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/18/ReactiveCocoa信号类分析/" class="post-title-link">ReactiveCocoa - 信号类分析</a></h2><div class="post-info">Aug 18, 2017</div><div class="post-content"><h2 id="信号类基础概念及原理"><a href="#信号类基础概念及原理" class="headerlink" title="信号类基础概念及原理"></a>信号类基础概念及原理</h2><h3 id="信号类的集成关系图"><a href="#信号类的集成关系图" class="headerlink" title="信号类的集成关系图"></a>信号类的集成关系图</h3><p><img src="/resources/FA1CDE683EA35A1CCDBAB883F9B0A64D.jpg" alt="IMAGE"></p></div><a href="/2017/08/18/ReactiveCocoa信号类分析/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2016 - 2018 <a href="http://www.zhz.io">HongZhi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-82278125-1",'auto');ga('send','pageview');</script></body></html>